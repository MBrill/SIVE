// --------------------------------------------------------------------
//  ReflectionLines.h
//
//  A class to represent reflection lines on a polygonal net
//  Derived from InterrogationLines
// --------------------------------------------------------------------
//  $RCSfile: ReflectionLines.h,v $
//  $Revision: 1.15 $
//  $Date: 2002/05/07 15:13:41 $
// --------------------------------------------------------------------
#ifndef REFLECTIONLINES_H
#define REFLECTIONLINES_H
#include <vtkPolyData.h>
#include <vtkScalars.h>
#include <vtkProperty.h>
#include <vtkRenderer.h>

#include <Performer/pr/pfTexture.h>

#include "InterrogationLines.h"
#include "InterrogationObject.h"
#include "LightCage.h"

//! A class representing reflection lines on a polygonal net
class ReflectionLines : public InterrogationLines
{
public:
   //! Default constructor, the pointers are created, no data
   /*!
     The render color is set to white, the eye point to (0,0,0) 
     PreFiltering is switched on.
   */
   ReflectionLines(void); // Default, lines created, no data
   //! Copy constructor
   ReflectionLines(const ReflectionLines& copy);
   //! Constructor setting the interrogated object and the light cage
   /*!
     The radius is set to 0.0 without querying the radius in the light cage.

     The render color is set to white, the eye point to (0,0,0)
     PreFiltering is switched on.
   */
   ReflectionLines(InterrogationObject *net, LightCage *lcage);
                      // no computation!
   //! Constructor setting the interrogated object and the light cage
   /*!
     The radius is set to r without querying the radius in the light cage.

     The render color is set to white, the eye point to (0,0,0)
     PreFiltering is switched on.
   */
   ReflectionLines(InterrogationObject *net, LightCage *lcage, float r);
   //! Constructor setting the interrogated object and the light cage
   /*!
     The radius is set to r without querying the radius in the light cage.
     If for light cylinders we render geometry we use num number of lines.
     A minimum reasonable number is 3, for the center line and the boundaries.

     The render color is set to white, the eye point to (0,0,0)
     PreFiltering is switched on.
   */
   ReflectionLines(InterrogationObject *net, LightCage *lcage, float r, int n);

   //! Destructor, deleting the vtkPolygonalData
   ~ReflectionLines(void);

   //! Compute the texture map for sphere mapping. 
   virtual pfTexture* computeTexture(int);
   //! Compute the texture coordinates
   /*!
     We use sphere mapping, so thats a dummy. The texture coordinates
     are generated by OpenGL.
   */
   virtual void       computeTextureCoordinates(void);
   //! Build the texture environment for OpenGL Performer
   /*!
     We blend the luminance values contained in the texture map for the
     highlight lines with the object color.
   */
   virtual pfTexEnv*  buildTexEnv(void);
   //! Build the texture coordinates generator in OpenGL Performer
   /*!
     The texture coordinate generator is set to sphere mapping for both
     texture coordinates s and t.
   */
   virtual pfTexGen*  buildTexGen(void);
   
   //! Save the computed texture map as vtkScalars
   vtkScalars* saveTexture(int);

private:
   //! Compute scalars to contour 
   /*!
     We compute the scalars as vtkScalars, for an individual line in the
     light cage. This function is called in compute().

     We use LightLine::reflectionValue() for the computation. Reflection lines
     are view dependent!
   */
   virtual void computeScalars(vtkScalars*, list<LightLine>::iterator); 

   // auxialiary function to help prefiltering the textures maps.
 
   void preFilter(int, float*, float*);
};
#endif
